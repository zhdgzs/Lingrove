# Design: 用百分比替换固定强度配置

## 架构决策

### 1. 为什么使用百分比而不是固定词数？

**问题：**
- 固定词数（4/8/14）在不同长度文本上表现不一致
- 1000 字符文本翻译 8 个词 = 0.8% 密度
- 100 字符文本翻译 8 个词 = 8% 密度（可能超出文本范围）

**解决方案：**
- 使用百分比确保翻译密度一致
- 30% 配置在任何长度文本上都保持 30% 的翻译密度
- 更直观的用户体验

### 2. 文本分块策略

**目标：**
- 每批次约 1000 字符（平衡 API 成本和翻译质量）
- 上限 1200 字符（避免超长请求）
- 保持段落语义完整

**实现：**
```javascript
// 伪代码
segments = []
currentBatch = []
currentLength = 0

for paragraph in paragraphs:
  if currentLength + paragraph.length > 1200:
    // 当前批次已满，发送
    segments.push(currentBatch)
    currentBatch = [paragraph]
    currentLength = paragraph.length
  else if currentLength + paragraph.length >= 800:
    // 接近目标，添加后发送
    currentBatch.push(paragraph)
    segments.push(currentBatch)
    currentBatch = []
    currentLength = 0
  else:
    // 继续累积
    currentBatch.push(paragraph)
    currentLength += paragraph.length

// 处理剩余
if currentBatch.length > 0:
  segments.push(currentBatch)
```

**优势：**
- 不会在段落中间切分（保持语义完整）
- 批次大小相对均匀（800-1200 字符）
- 减少 API 调用次数

### 3. 百分比传递给 AI

**核心原则：只传递百分比，让 AI 自行决策**

由于中英文字符与词汇的对应关系不同：
- 中文：2-4 字符 = 1 个词汇
- 英文：4-10 字符 = 1 个词汇

客户端无法准确计算词汇数量，因此：
- 只传递百分比给 AI
- AI 根据语言特性和上下文自行决定翻译哪些词汇
- AI 根据百分比控制翻译密度

**提示词示例：**
```
翻译密度：30%
请根据此密度选择适合学习的词汇进行翻译。
```

**优势：**
- AI 能更智能地选择词汇
- 避免客户端复杂的分词逻辑
- 自动适应中英文混合文本

### 4. 配置策略

**不做旧配置兼容：**
- 直接废弃旧的 `intensity` 配置
- 新配置 `translationDensity` 默认值：30%
- 简化代码，无需迁移逻辑

**百分比配置：**
- 预设档位：10%、30%、50%、70%
- 支持用户自定义百分比值（1-100%）
- 默认值：30%

### 5. 性能考虑

**API 调用优化：**
- 批量处理段落（减少请求次数）
- 保持现有的缓存机制
- 可视区域优先加载

**Token 使用：**
- 1000 字符文本 ≈ 250-300 tokens（英文）
- 1000 字符文本 ≈ 500-600 tokens（中文）
- 每批次 token 消耗可控

## 技术权衡

### 权衡 1：客户端计算 vs AI 决策

**选择：AI 决策**

| 方案 | 优点 | 缺点 |
|------|------|------|
| 客户端计算词数 | 精确控制 | 中英文混合复杂，需要复杂的分词逻辑 |
| AI 根据百分比决策 | 智能选择，适应多语言 | 词汇数量可能有波动 |

**决策理由：**
- AI 能更好地理解语义
- 避免客户端复杂的分词逻辑
- 支持未来扩展（如翻译句子）

### 权衡 2：固定分块 vs 动态分块

**选择：动态分块（按段落）**

| 方案 | 优点 | 缺点 |
|------|------|------|
| 固定 1000 字符切分 | 简单实现 | 可能破坏语义 |
| 按段落动态拼接 | 保持语义完整 | 批次大小有波动 |

**决策理由：**
- 语义完整性优先
- 批次大小波动可接受（800-1200）
- 翻译质量更重要

### 权衡 3：兼容旧配置 vs 直接废弃

**选择：直接废弃旧配置**

| 方案 | 优点 | 缺点 |
|------|------|------|
| 兼容旧配置 | 用户无感知 | 代码复杂，维护成本高 |
| 直接废弃 | 代码简洁 | 旧用户需重新配置 |

**决策理由：**
- 旧配置已不合理，应该废弃
- 默认 30% 对大多数用户适用
- 简化代码维护

## 风险与缓解

### 风险 1：翻译密度不符合预期

**风险：** AI 返回的词汇数量与百分比不匹配

**缓解：**
- 在提示词中明确指导 AI
- 添加验证逻辑，记录偏差
- 根据反馈调整提示词

### 风险 2：文本分块导致性能问题

**风险：** 大量小批次导致 API 调用过多

**缓解：**
- 设置最小批次大小（避免过小批次）
- 保持现有的请求间隔机制
- 监控 API 调用频率

## 实施顺序理由

1. **Phase 1（清理旧逻辑）先行**：删除旧代码，为新实现腾出空间
2. **Phase 2（配置层）次之**：建立新的配置基础
3. **Phase 3（核心逻辑）再次**：实现主要功能
4. **Phase 4（UI）然后**：用户可见的改动
5. **Phase 5（测试）验证**：确保质量

## 成功指标

- ✅ AI 根据百分比合理选择词汇（主观评估）
- ✅ 文本分块 100% 不超过 1200 字符
- ✅ 段落语义完整性 100%（不在段落中间切分）
- ✅ 翻译质量主观评分 ≥ 当前水平
- ✅ API 调用频率 ≤ 当前水平 × 1.2
